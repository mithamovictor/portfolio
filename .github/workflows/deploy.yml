name: Deploy Portfolio to Kubernetes

on:
  push:
    branches: [ main, dev ]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  NAMESPACE: portfolio
  APP_NAME: portfolio
  PNPM_VERSION: 10.28.0
  NODE_VERSION: 22

jobs:
  validate-secrets:
    runs-on: ubuntu-latest

    steps:
      - name: üîê Validate required secrets and variables
        run: |
          MISSING_ITEMS=()

          # Check KUBE_CONFIG secret
          if [ -z "${{ secrets.KUBE_CONFIG }}" ]; then
            MISSING_ITEMS+=("KUBE_CONFIG (secret)")
          fi

          # Check DEV_TO_API_KEY_PORTFOLIO secret
          if [ -z "${{ secrets.DEV_TO_API_KEY_PORTFOLIO }}" ]; then
            MISSING_ITEMS+=("DEV_TO_API_KEY_PORTFOLIO (secret)")
          fi

          # Check BREVO_API_KEY_PORTFOLIO secret
          if [ -z "${{ secrets.BREVO_API_KEY_PORTFOLIO }}" ]; then
            MISSING_ITEMS+=("BREVO_API_KEY_PORTFOLIO (secret)")
          fi

          # Check DEV_TO_API_URL variable
          if [ -z "${{ vars.DEV_TO_API_URL }}" ]; then
            MISSING_ITEMS+=("DEV_TO_API_URL (variable)")
          fi

          if [ ${#MISSING_ITEMS[@]} -gt 0 ]; then
            echo "‚ùå Missing required secrets/variables:"
            printf '%s\n' "${MISSING_ITEMS[@]}"
            echo ""
            echo "üìù Please set the following in GitHub:"
            echo "   Repository Settings ‚Üí Secrets and Variables ‚Üí Actions"
            echo ""
            echo "Required secrets:"
            echo "  - KUBE_CONFIG: Your Kubernetes config file (base64 encoded)"
            echo "  - DEV_TO_API_KEY_PORTFOLIO: Dev.to API key for portfolio"
            echo "  - BREVO_API_KEY_PORTFOLIO: Brevo API key for email"
            echo ""
            echo "Required variables:"
            echo "  - DEV_TO_API_URL: Dev.to API base URL"
            exit 1
          fi

          echo "‚úÖ All required secrets and variables are configured"

  code-security:
    needs: validate-secrets
    runs-on: ubuntu-latest
    permissions:
      contents: read
      security-events: write
      actions: read

    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üì¶ Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: ${{ env.PNPM_VERSION }}
          run_install: false

      - name: ‚ö° Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'pnpm'

      - name: üì• Install dependencies
        run: pnpm install --frozen-lockfile

      - name: üîí Run security audit
        run: |
          if [[ "${{ github.ref_name }}" == "dev" ]] || [[ "${{ github.ref_name }}" == "staging" ]]; then
            pnpm audit --audit-level=low || true
          else
            pnpm audit --audit-level=high
          fi

      - name: üîç Run Semgrep security scan
        uses: returntocorp/semgrep-action@v1
        with:
          config: p/ci

      - name: üîê Run Trivy vulnerability scan (filesystem)
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'table'
          severity: 'CRITICAL,HIGH,MEDIUM,LOW,UNKNOWN'
          exit-code: '0'

  build:
    needs: validate-secrets
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
      - uses: actions/checkout@v4

      - name: üîê Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: üîß Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: üèóÔ∏è Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }},${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
          cache-from: type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:buildcache
          cache-to: type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:buildcache,mode=max

      - name: üîê Run Trivy scan on Docker image
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
          format: 'table'
          severity: 'CRITICAL,HIGH'
          exit-code: '1'
          scanners: 'vuln'

  deploy:
    needs: [code-security, build]
    runs-on: [self-hosted, alma9]

    concurrency:
      group: deploy-portfolio-${{ github.ref_name }}
      cancel-in-progress: false

    steps:
      - uses: actions/checkout@v4

      - name: üîß Set up kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: üèóÔ∏è Configure kubectl context
        run: |
          mkdir -p $HOME/.kube
          echo "${{ secrets.KUBE_CONFIG }}" | base64 -d > $HOME/.kube/config
          chmod 600 $HOME/.kube/config
          kubectl cluster-info

      - name: üìù Create namespace
        run: |
          kubectl create namespace ${{ env.NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -

      - name: üîê Create environment secret
        run: |
          kubectl create secret generic ${{ env.APP_NAME }}-env \
            --from-literal=BREVO_API_KEY="${{ secrets.BREVO_API_KEY_PORTFOLIO }}" \
            --from-literal=DEV_TO_API_KEY="${{ secrets.DEV_TO_API_KEY_PORTFOLIO }}" \
            --from-literal=DEV_TO_API_URL="${{ vars.DEV_TO_API_URL }}" \
            -n ${{ env.NAMESPACE }} \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: üíæ Save current deployment state
        id: previous-state
        continue-on-error: true
        run: |
          DEPLOYMENT_NAME="${{ env.APP_NAME }}-${{ github.ref_name }}"
          echo "deployment_name=$DEPLOYMENT_NAME" >> $GITHUB_OUTPUT

          CURRENT_REPLICAS=$(kubectl get deployment $DEPLOYMENT_NAME -n ${{ env.NAMESPACE }} -o jsonpath='{.spec.replicas}' 2>/dev/null || echo "0")
          CURRENT_IMAGE=$(kubectl get deployment $DEPLOYMENT_NAME -n ${{ env.NAMESPACE }} -o jsonpath='{.spec.template.spec.containers[0].image}' 2>/dev/null || echo "")

          echo "current_replicas=$CURRENT_REPLICAS" >> $GITHUB_OUTPUT
          echo "current_image=$CURRENT_IMAGE" >> $GITHUB_OUTPUT

          if [ -n "$CURRENT_IMAGE" ]; then
            echo "‚úÖ Saved previous deployment state:"
            echo "  - Replicas: $CURRENT_REPLICAS"
            echo "  - Image: $CURRENT_IMAGE"
          else
            echo "‚ÑπÔ∏è No previous deployment found (first deployment)"
          fi

      - name: üì¶ Deploy to Kubernetes
        run: |
          kubectl apply -f - <<EOF
          ---
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: ${{ env.APP_NAME }}-${{ github.ref_name }}
            namespace: ${{ env.NAMESPACE }}
            labels:
              app: ${{ env.APP_NAME }}
              branch: ${{ github.ref_name }}
          spec:
            replicas: 2
            strategy:
              type: RollingUpdate
              rollingUpdate:
                maxSurge: 1
                maxUnavailable: 0
            selector:
              matchLabels:
                app: ${{ env.APP_NAME }}
                branch: ${{ github.ref_name }}
            template:
              metadata:
                labels:
                  app: ${{ env.APP_NAME }}
                  branch: ${{ github.ref_name }}
              spec:
                containers:
                  - name: ${{ env.APP_NAME }}
                    image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
                    imagePullPolicy: Always
                    ports:
                      - name: http
                        containerPort: 3000
                    env:
                      - name: BREVO_API_KEY
                        valueFrom:
                          secretKeyRef:
                            name: ${{ env.APP_NAME }}-env
                            key: BREVO_API_KEY
                      - name: DEV_TO_API_KEY
                        valueFrom:
                          secretKeyRef:
                            name: ${{ env.APP_NAME }}-env
                            key: DEV_TO_API_KEY
                      - name: DEV_TO_API_URL
                        valueFrom:
                          secretKeyRef:
                            name: ${{ env.APP_NAME }}-env
                            key: DEV_TO_API_URL
                      - name: NODE_ENV
                        value: "production"
                    resources:
                      requests:
                        cpu: 100m
                        memory: 256Mi
                      limits:
                        cpu: 500m
                        memory: 512Mi
                    livenessProbe:
                      httpGet:
                        path: /
                        port: http
                      initialDelaySeconds: 30
                      periodSeconds: 10
                      timeoutSeconds: 5
                      failureThreshold: 3
                    readinessProbe:
                      httpGet:
                        path: /
                        port: http
                      initialDelaySeconds: 10
                      periodSeconds: 5
                      timeoutSeconds: 3
                      failureThreshold: 2
          ---
          apiVersion: v1
          kind: Service
          metadata:
            name: ${{ env.APP_NAME }}-${{ github.ref_name }}
            namespace: ${{ env.NAMESPACE }}
            labels:
              app: ${{ env.APP_NAME }}
              branch: ${{ github.ref_name }}
          spec:
            type: ClusterIP
            selector:
              app: ${{ env.APP_NAME }}
              branch: ${{ github.ref_name }}
            ports:
              - name: http
                port: 3000
                targetPort: http
          ---
          apiVersion: networking.k8s.io/v1
          kind: Ingress
          metadata:
            name: ${{ env.APP_NAME }}-${{ github.ref_name }}
            namespace: ${{ env.NAMESPACE }}
            annotations:
              cert-manager.io/cluster-issuer: letsencrypt-prod
              kubernetes.io/ingress.class: nginx
          spec:
            tls:
              - hosts:
                  - mithamo.cc
                secretName: ${{ env.APP_NAME }}-${{ github.ref_name }}-tls
            rules:
              - host: mithamo.cc
                http:
                  paths:
                    - path: /
                      pathType: Prefix
                      backend:
                        service:
                          name: ${{ env.APP_NAME }}-${{ github.ref_name }}
                          port:
                            number: 3000
          EOF

      - name: ‚è≥ Wait for deployment rollout
        run: |
          kubectl rollout status deployment/${{ env.APP_NAME }}-${{ github.ref_name }} -n ${{ env.NAMESPACE }} --timeout=5m

  test-deployment:
    needs: deploy
    runs-on: [self-hosted, alma9]

    steps:
      - name: üîß Set up kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: üèóÔ∏è Configure kubectl context
        run: |
          mkdir -p $HOME/.kube
          echo "${{ secrets.KUBE_CONFIG }}" | base64 -d > $HOME/.kube/config
          chmod 600 $HOME/.kube/config

      - name: ‚úÖ Health check
        id: health-check
        run: |
          SERVICE_NAME="${{ env.APP_NAME }}-${{ github.ref_name }}"
          SERVICE_IP=$(kubectl get service $SERVICE_NAME -n ${{ env.NAMESPACE }} -o jsonpath='{.spec.clusterIP}' || echo "")

          if [ -z "$SERVICE_IP" ]; then
            echo "‚ùå Could not find Service IP for $SERVICE_NAME"
            kubectl get svc -n ${{ env.NAMESPACE }}
            exit 1
          fi

          echo "Checking health at http://$SERVICE_IP:3000"

          for i in {1..20}; do
            echo "Attempt $i: Waiting for application..."
            if kubectl run -n ${{ env.NAMESPACE }} --rm -i --restart=Never --image=curlimages/curl:latest curl-check-$i -- curl -s -f "http://$SERVICE_IP:3000" > /dev/null 2>&1; then
              echo "‚úÖ Application is healthy"
              echo "health_status=success" >> $GITHUB_OUTPUT
              exit 0
            fi
            echo "Retrying in 10 seconds..."
            sleep 10
          done

          echo "‚ùå Application failed to start or is unreachable after 200 seconds"
          echo "health_status=failed" >> $GITHUB_OUTPUT
          echo ""
          echo "--- POD STATUS ---"
          kubectl get pods -n ${{ env.NAMESPACE }} -l app=${{ env.APP_NAME }},branch=${{ github.ref_name }}

          echo ""
          echo "--- SERVICE DETAILS ---"
          kubectl describe service $SERVICE_NAME -n ${{ env.NAMESPACE }}

          echo ""
          echo "--- ENDPOINTS ---"
          kubectl get endpoints $SERVICE_NAME -n ${{ env.NAMESPACE }}

          echo ""
          echo "--- RECENT POD LOGS ---"
          POD_NAME=$(kubectl get pods -n ${{ env.NAMESPACE }} -l app=${{ env.APP_NAME }},branch=${{ github.ref_name }} -o jsonpath='{.items[0].metadata.name}' || echo "")
          if [ -n "$POD_NAME" ]; then
            kubectl logs $POD_NAME -n ${{ env.NAMESPACE }} --tail=50
          fi
          exit 1

      - name: üîç Deployment status
        if: success()
        run: |
          echo "### Deployment Status"
          kubectl get deployment -n ${{ env.NAMESPACE }} -l app=${{ env.APP_NAME }}
          echo ""
          echo "### Pods"
          kubectl get pods -n ${{ env.NAMESPACE }} -l app=${{ env.APP_NAME }},branch=${{ github.ref_name }} -o wide
          echo ""
          echo "### Services"
          kubectl get svc -n ${{ env.NAMESPACE }} -l app=${{ env.APP_NAME }}
          echo ""
          echo "### Ingress"
          kubectl get ingress -n ${{ env.NAMESPACE }} -l app=${{ env.APP_NAME }}

      - name: üìä Deployment summary
        if: success()
        run: |
          {
            echo "## üéâ Portfolio Deployment Successful"
            echo ""
            echo "### Application Details"
            echo "- **App**: ${{ env.APP_NAME }}-${{ github.ref_name }}"
            echo "- **Branch**: ${{ github.ref_name }}"
            echo "- **Image**: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}"
            echo "- **Namespace**: ${{ env.NAMESPACE }}"
            echo ""
            echo "### Access URLs"
            echo "- **URL**: https://mithamo.cc"
          } >> $GITHUB_STEP_SUMMARY

  rollback:
    if: failure() && needs.test-deployment.result == 'failure'
    needs: [deploy, test-deployment]
    runs-on: [self-hosted, alma9]

    steps:
      - name: üîß Set up kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: üèóÔ∏è Configure kubectl context
        run: |
          mkdir -p $HOME/.kube
          echo "${{ secrets.KUBE_CONFIG }}" | base64 -d > $HOME/.kube/config
          chmod 600 $HOME/.kube/config

      - name: üíæ Retrieve previous state
        id: previous-state
        continue-on-error: true
        run: |
          DEPLOYMENT_NAME="${{ env.APP_NAME }}-${{ github.ref_name }}"
          echo "deployment_name=$DEPLOYMENT_NAME" >> $GITHUB_OUTPUT

          CURRENT_IMAGE=$(kubectl get deployment $DEPLOYMENT_NAME -n ${{ env.NAMESPACE }} -o jsonpath='{.spec.template.spec.containers[0].image}' 2>/dev/null || echo "")

          echo "current_image=$CURRENT_IMAGE" >> $GITHUB_OUTPUT

          if [ -n "$CURRENT_IMAGE" ]; then
            echo "Current deployment image: $CURRENT_IMAGE"
          else
            echo "No previous deployment found"
          fi

      - name: üîÑ Rollback deployment
        if: steps.previous-state.outputs.current_image != ''
        run: |
          DEPLOYMENT_NAME="${{ steps.previous-state.outputs.deployment_name }}"

          echo "‚ö†Ô∏è Deployment tests failed. Rolling back to previous version..."

          kubectl rollout undo deployment/$DEPLOYMENT_NAME -n ${{ env.NAMESPACE }}

          kubectl rollout status deployment/$DEPLOYMENT_NAME -n ${{ env.NAMESPACE }} --timeout=5m

          echo "‚úÖ Rollback completed successfully"
          echo ""
          echo "--- ROLLED BACK DEPLOYMENT STATUS ---"
          kubectl get deployment $DEPLOYMENT_NAME -n ${{ env.NAMESPACE }} -o wide

      - name: üö® Rollback notification
        if: steps.previous-state.outputs.current_image == ''
        run: |
          echo "‚ùå Deployment tests failed and no previous version exists to rollback to."
          echo "This was likely the first deployment. Please investigate the deployment logs above."
          exit 1
